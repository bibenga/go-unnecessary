// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"unnecessary/db/model"
)

func newApplicationTag(db *gorm.DB, opts ...gen.DOOption) applicationTag {
	_applicationTag := applicationTag{}

	_applicationTag.applicationTagDo.UseDB(db, opts...)
	_applicationTag.applicationTagDo.UseModel(&model.ApplicationTag{})

	tableName := _applicationTag.applicationTagDo.TableName()
	_applicationTag.ALL = field.NewAsterisk(tableName)
	_applicationTag.ID = field.NewInt64(tableName, "id")
	_applicationTag.ApplicationID = field.NewInt64(tableName, "application_id")
	_applicationTag.TagID = field.NewInt64(tableName, "tag_id")
	_applicationTag.CreatedTs = field.NewTime(tableName, "created_ts")
	_applicationTag.Application = applicationTagBelongsToApplication{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Application", "model.Application"),
		DictPlatform: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Application.DictPlatform", "model.DictPlatform"),
		},
		Tags: struct {
			field.RelationField
		}{
			RelationField: field.NewRelation("Application.Tags", "model.Tag"),
		},
	}

	_applicationTag.Tag = applicationTagBelongsToTag{
		db: db.Session(&gorm.Session{}),

		RelationField: field.NewRelation("Tag", "model.Tag"),
	}

	_applicationTag.fillFieldMap()

	return _applicationTag
}

type applicationTag struct {
	applicationTagDo applicationTagDo

	ALL           field.Asterisk
	ID            field.Int64
	ApplicationID field.Int64
	TagID         field.Int64
	CreatedTs     field.Time
	Application   applicationTagBelongsToApplication

	Tag applicationTagBelongsToTag

	fieldMap map[string]field.Expr
}

func (a applicationTag) Table(newTableName string) *applicationTag {
	a.applicationTagDo.UseTable(newTableName)
	return a.updateTableName(newTableName)
}

func (a applicationTag) As(alias string) *applicationTag {
	a.applicationTagDo.DO = *(a.applicationTagDo.As(alias).(*gen.DO))
	return a.updateTableName(alias)
}

func (a *applicationTag) updateTableName(table string) *applicationTag {
	a.ALL = field.NewAsterisk(table)
	a.ID = field.NewInt64(table, "id")
	a.ApplicationID = field.NewInt64(table, "application_id")
	a.TagID = field.NewInt64(table, "tag_id")
	a.CreatedTs = field.NewTime(table, "created_ts")

	a.fillFieldMap()

	return a
}

func (a *applicationTag) WithContext(ctx context.Context) IApplicationTagDo {
	return a.applicationTagDo.WithContext(ctx)
}

func (a applicationTag) TableName() string { return a.applicationTagDo.TableName() }

func (a applicationTag) Alias() string { return a.applicationTagDo.Alias() }

func (a *applicationTag) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := a.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (a *applicationTag) fillFieldMap() {
	a.fieldMap = make(map[string]field.Expr, 6)
	a.fieldMap["id"] = a.ID
	a.fieldMap["application_id"] = a.ApplicationID
	a.fieldMap["tag_id"] = a.TagID
	a.fieldMap["created_ts"] = a.CreatedTs

}

func (a applicationTag) clone(db *gorm.DB) applicationTag {
	a.applicationTagDo.ReplaceConnPool(db.Statement.ConnPool)
	return a
}

func (a applicationTag) replaceDB(db *gorm.DB) applicationTag {
	a.applicationTagDo.ReplaceDB(db)
	return a
}

type applicationTagBelongsToApplication struct {
	db *gorm.DB

	field.RelationField

	DictPlatform struct {
		field.RelationField
	}
	Tags struct {
		field.RelationField
	}
}

func (a applicationTagBelongsToApplication) Where(conds ...field.Expr) *applicationTagBelongsToApplication {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a applicationTagBelongsToApplication) WithContext(ctx context.Context) *applicationTagBelongsToApplication {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a applicationTagBelongsToApplication) Session(session *gorm.Session) *applicationTagBelongsToApplication {
	a.db = a.db.Session(session)
	return &a
}

func (a applicationTagBelongsToApplication) Model(m *model.ApplicationTag) *applicationTagBelongsToApplicationTx {
	return &applicationTagBelongsToApplicationTx{a.db.Model(m).Association(a.Name())}
}

type applicationTagBelongsToApplicationTx struct{ tx *gorm.Association }

func (a applicationTagBelongsToApplicationTx) Find() (result *model.Application, err error) {
	return result, a.tx.Find(&result)
}

func (a applicationTagBelongsToApplicationTx) Append(values ...*model.Application) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a applicationTagBelongsToApplicationTx) Replace(values ...*model.Application) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a applicationTagBelongsToApplicationTx) Delete(values ...*model.Application) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a applicationTagBelongsToApplicationTx) Clear() error {
	return a.tx.Clear()
}

func (a applicationTagBelongsToApplicationTx) Count() int64 {
	return a.tx.Count()
}

type applicationTagBelongsToTag struct {
	db *gorm.DB

	field.RelationField
}

func (a applicationTagBelongsToTag) Where(conds ...field.Expr) *applicationTagBelongsToTag {
	if len(conds) == 0 {
		return &a
	}

	exprs := make([]clause.Expression, 0, len(conds))
	for _, cond := range conds {
		exprs = append(exprs, cond.BeCond().(clause.Expression))
	}
	a.db = a.db.Clauses(clause.Where{Exprs: exprs})
	return &a
}

func (a applicationTagBelongsToTag) WithContext(ctx context.Context) *applicationTagBelongsToTag {
	a.db = a.db.WithContext(ctx)
	return &a
}

func (a applicationTagBelongsToTag) Session(session *gorm.Session) *applicationTagBelongsToTag {
	a.db = a.db.Session(session)
	return &a
}

func (a applicationTagBelongsToTag) Model(m *model.ApplicationTag) *applicationTagBelongsToTagTx {
	return &applicationTagBelongsToTagTx{a.db.Model(m).Association(a.Name())}
}

type applicationTagBelongsToTagTx struct{ tx *gorm.Association }

func (a applicationTagBelongsToTagTx) Find() (result *model.Tag, err error) {
	return result, a.tx.Find(&result)
}

func (a applicationTagBelongsToTagTx) Append(values ...*model.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Append(targetValues...)
}

func (a applicationTagBelongsToTagTx) Replace(values ...*model.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Replace(targetValues...)
}

func (a applicationTagBelongsToTagTx) Delete(values ...*model.Tag) (err error) {
	targetValues := make([]interface{}, len(values))
	for i, v := range values {
		targetValues[i] = v
	}
	return a.tx.Delete(targetValues...)
}

func (a applicationTagBelongsToTagTx) Clear() error {
	return a.tx.Clear()
}

func (a applicationTagBelongsToTagTx) Count() int64 {
	return a.tx.Count()
}

type applicationTagDo struct{ gen.DO }

type IApplicationTagDo interface {
	gen.SubQuery
	Debug() IApplicationTagDo
	WithContext(ctx context.Context) IApplicationTagDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() IApplicationTagDo
	WriteDB() IApplicationTagDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) IApplicationTagDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) IApplicationTagDo
	Not(conds ...gen.Condition) IApplicationTagDo
	Or(conds ...gen.Condition) IApplicationTagDo
	Select(conds ...field.Expr) IApplicationTagDo
	Where(conds ...gen.Condition) IApplicationTagDo
	Order(conds ...field.Expr) IApplicationTagDo
	Distinct(cols ...field.Expr) IApplicationTagDo
	Omit(cols ...field.Expr) IApplicationTagDo
	Join(table schema.Tabler, on ...field.Expr) IApplicationTagDo
	LeftJoin(table schema.Tabler, on ...field.Expr) IApplicationTagDo
	RightJoin(table schema.Tabler, on ...field.Expr) IApplicationTagDo
	Group(cols ...field.Expr) IApplicationTagDo
	Having(conds ...gen.Condition) IApplicationTagDo
	Limit(limit int) IApplicationTagDo
	Offset(offset int) IApplicationTagDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) IApplicationTagDo
	Unscoped() IApplicationTagDo
	Create(values ...*model.ApplicationTag) error
	CreateInBatches(values []*model.ApplicationTag, batchSize int) error
	Save(values ...*model.ApplicationTag) error
	First() (*model.ApplicationTag, error)
	Take() (*model.ApplicationTag, error)
	Last() (*model.ApplicationTag, error)
	Find() ([]*model.ApplicationTag, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ApplicationTag, err error)
	FindInBatches(result *[]*model.ApplicationTag, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.ApplicationTag) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) IApplicationTagDo
	Assign(attrs ...field.AssignExpr) IApplicationTagDo
	Joins(fields ...field.RelationField) IApplicationTagDo
	Preload(fields ...field.RelationField) IApplicationTagDo
	FirstOrInit() (*model.ApplicationTag, error)
	FirstOrCreate() (*model.ApplicationTag, error)
	FindByPage(offset int, limit int) (result []*model.ApplicationTag, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) IApplicationTagDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (a applicationTagDo) Debug() IApplicationTagDo {
	return a.withDO(a.DO.Debug())
}

func (a applicationTagDo) WithContext(ctx context.Context) IApplicationTagDo {
	return a.withDO(a.DO.WithContext(ctx))
}

func (a applicationTagDo) ReadDB() IApplicationTagDo {
	return a.Clauses(dbresolver.Read)
}

func (a applicationTagDo) WriteDB() IApplicationTagDo {
	return a.Clauses(dbresolver.Write)
}

func (a applicationTagDo) Session(config *gorm.Session) IApplicationTagDo {
	return a.withDO(a.DO.Session(config))
}

func (a applicationTagDo) Clauses(conds ...clause.Expression) IApplicationTagDo {
	return a.withDO(a.DO.Clauses(conds...))
}

func (a applicationTagDo) Returning(value interface{}, columns ...string) IApplicationTagDo {
	return a.withDO(a.DO.Returning(value, columns...))
}

func (a applicationTagDo) Not(conds ...gen.Condition) IApplicationTagDo {
	return a.withDO(a.DO.Not(conds...))
}

func (a applicationTagDo) Or(conds ...gen.Condition) IApplicationTagDo {
	return a.withDO(a.DO.Or(conds...))
}

func (a applicationTagDo) Select(conds ...field.Expr) IApplicationTagDo {
	return a.withDO(a.DO.Select(conds...))
}

func (a applicationTagDo) Where(conds ...gen.Condition) IApplicationTagDo {
	return a.withDO(a.DO.Where(conds...))
}

func (a applicationTagDo) Exists(subquery interface{ UnderlyingDB() *gorm.DB }) IApplicationTagDo {
	return a.Where(field.CompareSubQuery(field.ExistsOp, nil, subquery.UnderlyingDB()))
}

func (a applicationTagDo) Order(conds ...field.Expr) IApplicationTagDo {
	return a.withDO(a.DO.Order(conds...))
}

func (a applicationTagDo) Distinct(cols ...field.Expr) IApplicationTagDo {
	return a.withDO(a.DO.Distinct(cols...))
}

func (a applicationTagDo) Omit(cols ...field.Expr) IApplicationTagDo {
	return a.withDO(a.DO.Omit(cols...))
}

func (a applicationTagDo) Join(table schema.Tabler, on ...field.Expr) IApplicationTagDo {
	return a.withDO(a.DO.Join(table, on...))
}

func (a applicationTagDo) LeftJoin(table schema.Tabler, on ...field.Expr) IApplicationTagDo {
	return a.withDO(a.DO.LeftJoin(table, on...))
}

func (a applicationTagDo) RightJoin(table schema.Tabler, on ...field.Expr) IApplicationTagDo {
	return a.withDO(a.DO.RightJoin(table, on...))
}

func (a applicationTagDo) Group(cols ...field.Expr) IApplicationTagDo {
	return a.withDO(a.DO.Group(cols...))
}

func (a applicationTagDo) Having(conds ...gen.Condition) IApplicationTagDo {
	return a.withDO(a.DO.Having(conds...))
}

func (a applicationTagDo) Limit(limit int) IApplicationTagDo {
	return a.withDO(a.DO.Limit(limit))
}

func (a applicationTagDo) Offset(offset int) IApplicationTagDo {
	return a.withDO(a.DO.Offset(offset))
}

func (a applicationTagDo) Scopes(funcs ...func(gen.Dao) gen.Dao) IApplicationTagDo {
	return a.withDO(a.DO.Scopes(funcs...))
}

func (a applicationTagDo) Unscoped() IApplicationTagDo {
	return a.withDO(a.DO.Unscoped())
}

func (a applicationTagDo) Create(values ...*model.ApplicationTag) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Create(values)
}

func (a applicationTagDo) CreateInBatches(values []*model.ApplicationTag, batchSize int) error {
	return a.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (a applicationTagDo) Save(values ...*model.ApplicationTag) error {
	if len(values) == 0 {
		return nil
	}
	return a.DO.Save(values)
}

func (a applicationTagDo) First() (*model.ApplicationTag, error) {
	if result, err := a.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApplicationTag), nil
	}
}

func (a applicationTagDo) Take() (*model.ApplicationTag, error) {
	if result, err := a.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApplicationTag), nil
	}
}

func (a applicationTagDo) Last() (*model.ApplicationTag, error) {
	if result, err := a.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApplicationTag), nil
	}
}

func (a applicationTagDo) Find() ([]*model.ApplicationTag, error) {
	result, err := a.DO.Find()
	return result.([]*model.ApplicationTag), err
}

func (a applicationTagDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.ApplicationTag, err error) {
	buf := make([]*model.ApplicationTag, 0, batchSize)
	err = a.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (a applicationTagDo) FindInBatches(result *[]*model.ApplicationTag, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return a.DO.FindInBatches(result, batchSize, fc)
}

func (a applicationTagDo) Attrs(attrs ...field.AssignExpr) IApplicationTagDo {
	return a.withDO(a.DO.Attrs(attrs...))
}

func (a applicationTagDo) Assign(attrs ...field.AssignExpr) IApplicationTagDo {
	return a.withDO(a.DO.Assign(attrs...))
}

func (a applicationTagDo) Joins(fields ...field.RelationField) IApplicationTagDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Joins(_f))
	}
	return &a
}

func (a applicationTagDo) Preload(fields ...field.RelationField) IApplicationTagDo {
	for _, _f := range fields {
		a = *a.withDO(a.DO.Preload(_f))
	}
	return &a
}

func (a applicationTagDo) FirstOrInit() (*model.ApplicationTag, error) {
	if result, err := a.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApplicationTag), nil
	}
}

func (a applicationTagDo) FirstOrCreate() (*model.ApplicationTag, error) {
	if result, err := a.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.ApplicationTag), nil
	}
}

func (a applicationTagDo) FindByPage(offset int, limit int) (result []*model.ApplicationTag, count int64, err error) {
	result, err = a.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = a.Offset(-1).Limit(-1).Count()
	return
}

func (a applicationTagDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = a.Count()
	if err != nil {
		return
	}

	err = a.Offset(offset).Limit(limit).Scan(result)
	return
}

func (a applicationTagDo) Scan(result interface{}) (err error) {
	return a.DO.Scan(result)
}

func (a applicationTagDo) Delete(models ...*model.ApplicationTag) (result gen.ResultInfo, err error) {
	return a.DO.Delete(models)
}

func (a *applicationTagDo) withDO(do gen.Dao) *applicationTagDo {
	a.DO = *do.(*gen.DO)
	return a
}
